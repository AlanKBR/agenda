<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Agenda odontológica moderna com FullCalendar e Flask.">
    <meta name="keywords" content="agenda, odontologia, calendário, fullcalendar, flask, consulta, clínica">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OdontoClin - Agenda</title>
    <!-- Bootstrap 5 CSS local -->
    <link href="/static/bootstrap.min.css" rel="stylesheet">
    <!-- Removido: Bootstrap Icons via CDN (operaremos sem ícones remotos) -->
    <!-- FullCalendar local bundle + plugins -->
    <script src="/static/fullcalendar/fullcalendar.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/daygrid.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/timegrid.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/list.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/interaction.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/multimonth.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/scrollgrid.global.min.js"></script>
    <script src="/static/fullcalendar/plugins/adaptive.global.min.js"></script>
    <!-- Bootstrap 5 JS local -->
    <script src="/static/bootstrap.bundle.min.js"></script>
    <!-- flatpickr local (leve, sem jQuery) para controle 24h consistente -->
    <link rel="stylesheet" href="/static/vendor/flatpickr/flatpickr.min.css">
    <script src="/static/vendor/flatpickr/flatpickr.min.js"></script>
    <script src="/static/vendor/flatpickr/l10n/pt.js"></script>
    <!-- CSS customizado -->
    <link href="/static/calendar-theme.css" rel="stylesheet">
    <!-- Tema dinâmico (override) -->
    <link id="theme-override" rel="stylesheet">
    <style>
        /* holiday highlight */
        .fc-day-holiday,
        .fc-holiday-bg {
            background: #ffe8e8 !important;
        }

        .fc-daygrid-day.fc-day-holiday .fc-daygrid-day-number::after {
            content: '★';
            color: #dc2626;
            font-size: 0.7rem;
            margin-left: 4px;
        }
    </style>
</head>

<body>
    <div id="calendar"></div>
    <div id="popover-container"></div>
    <div id="contextmenu-container"></div>
    <div id="settingsmenu-container"></div>

    <!-- Script principal do calendário (corrigido e único) -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            Promise.all([
                fetch('/static/event-popover.html').then(res => res.text()),
                fetch('/static/event-contextmenu.html').then(res => res.text()),
                fetch('/static/event-detail-popover.html').then(res => res.text()),
                fetch('/static/settings-menu.html').then(res => res.text())
            ]).then(([popoverHtml, contextHtml, detailPopoverHtml, settingsMenuHtml]) => {
                document.getElementById('popover-container').innerHTML = popoverHtml;
                document.getElementById('contextmenu-container').innerHTML = contextHtml;
                document.body.insertAdjacentHTML('beforeend', detailPopoverHtml);
                document.getElementById('settingsmenu-container').innerHTML = settingsMenuHtml;

                // Inicialização global dos pickers para garantir formato BR mesmo antes da seleção
                try {
                    const s1 = document.getElementById('popoverEventStart');
                    const e1 = document.getElementById('popoverEventEnd');
                    const sD = document.getElementById('popoverEventStartDate');
                    const eD = document.getElementById('popoverEventEndDate');
                    if (window.flatpickr && s1 && e1 && sD && eD) {
                        const fpDateOpts = {
                            enableTime: false,
                            allowInput: true,
                            locale: (window.flatpickr && window.flatpickr.l10ns && window.flatpickr.l10ns.pt) ? window.flatpickr.l10ns.pt : 'pt',
                            dateFormat: 'Y-m-d',
                            altInput: true,
                            altFormat: 'd/m/Y'
                        };
                        const fpDateTimeOpts = {
                            enableTime: true,
                            time_24hr: true,
                            allowInput: true,
                            minuteIncrement: 5,
                            locale: (window.flatpickr && window.flatpickr.l10ns && window.flatpickr.l10ns.pt) ? window.flatpickr.l10ns.pt : 'pt',
                            dateFormat: 'Y-m-d\\TH:i',
                            altInput: true,
                            altFormat: 'd/m/Y H:i'
                        };
                        // Pickers são destruídos/recriados quando o modo muda (allDay vs time)
                        flatpickr(s1, fpDateTimeOpts);
                        flatpickr(e1, fpDateTimeOpts);
                        flatpickr(sD, fpDateOpts);
                        flatpickr(eD, fpDateOpts);
                    }
                } catch (e) {
                    /* noop */ }

                // Aplicar tema salvo (se houver)
                const savedTheme = localStorage.getItem('calendarTheme') || 'default';
                applyTheme(savedTheme, false);

                const plugins = [];
                if (window.FullCalendar) {
                    if (FullCalendar.timeGridPlugin) plugins.push(FullCalendar.timeGridPlugin);
                    if (FullCalendar.listPlugin) plugins.push(FullCalendar.listPlugin);
                    if (FullCalendar.interactionPlugin) plugins.push(FullCalendar.interactionPlugin);
                    if (FullCalendar.multiMonthPlugin) plugins.push(FullCalendar.multiMonthPlugin);
                    if (FullCalendar.scrollGridPlugin) plugins.push(FullCalendar.scrollGridPlugin);
                    if (FullCalendar.adaptivePlugin) plugins.push(FullCalendar.adaptivePlugin);
                }
                const calendarEl = document.getElementById('calendar');
                // Helper: detect a Brazilian phone number within free text (first match)
                function extractPhoneFromText(text) {
                    if (!text) return null;
                    try {
                        // Supports formats like: +55 11 91234-5678, (11) 91234-5678, 112345-6789, 1234-5678, 9 1234-5678
                        const re = /(?:\+?55[\s\-.]?)?(?:\(?\d{2}\)?[\s\-.]?)?(?:9\d{4}|\d{4})[\s\-.]?\d{4}\b/;
                        const m = String(text).match(re);
                        return m ? m[0].trim() : null;
                    } catch (e) {
                        return null;
                    }
                }
                // Helper: format Date to local 'YYYY-MM-DDTHH:MM' string
                function formatLocalYmdHm(d) {
                    const pad = (n) => String(n).padStart(2, '0');
                    const y = d.getFullYear();
                    const m = pad(d.getMonth() + 1);
                    const day = pad(d.getDate());
                    const h = pad(d.getHours());
                    const min = pad(d.getMinutes());
                    return `${y}-${m}-${day}T${h}:${min}`;
                }

                // Weekends setting (for week view)
                function getWeekendsSetting() {
                    const v = localStorage.getItem('timeGridWeek_weekends');
                    return v === null ? true : v === 'true';
                }

                function setWeekendsSetting(val) {
                    try {
                        localStorage.setItem('timeGridWeek_weekends', String(!!val));
                    } catch (e) {}
                }

                // Client-side holiday cache
                let holidayDates = new Set(); // visible set 'YYYY-MM-DD'
                let holidayMeta = {}; // visible map date -> meta
                const dayCellEls = {}; // date -> [elements]
                // Session in-memory cache by year to avoid repeated GETs
                const holidaysYearCache = {}; // { [year]: { dates:Set, meta:{[date]:meta} } }
                const holidaysYearPending = {}; // { [year]: Promise }

                function toLocalISO(date) {
                    const pad = (n) => String(n).padStart(2, '0');
                    return [
                        date.getFullYear(),
                        pad(date.getMonth() + 1),
                        pad(date.getDate())
                    ].join('-');
                }

                function syncHolidayHighlight() {
                    Object.keys(dayCellEls).forEach(d => {
                        (dayCellEls[d] || []).forEach(el => {
                            if (!el || !el.classList) return;
                            if (holidayDates.has(d)) {
                                el.classList.add('fc-day-holiday');
                                const meta = holidayMeta[d];
                                if (meta && el.setAttribute) {
                                    el.setAttribute('title', meta.name);
                                }
                            } else {
                                el.classList.remove('fc-day-holiday');
                                if (el.getAttribute && el.getAttribute('title')) {
                                    el.removeAttribute('title');
                                }
                            }
                        });
                    });
                }

                function ymdFromDate(d) {
                    const pad = n => String(n).padStart(2, '0');
                    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
                }
                function yearsInRangeInclusive(startDate, endDateInclusive) {
                    const ys = [];
                    const y1 = startDate.getFullYear();
                    const y2 = endDateInclusive.getFullYear();
                    for (let y = y1; y <= y2; y++) ys.push(y);
                    return ys;
                }
                function ensureYearCached(year) {
                    if (holidaysYearCache[year]) return Promise.resolve();
                    if (holidaysYearPending[year]) return holidaysYearPending[year];
                    const p = fetch(`/holidays/year?year=${year}`)
                        .then(r => r.json())
                        .then(list => {
                            const dates = new Set(list.map(h => h.date));
                            const meta = {};
                            list.forEach(h => { meta[h.date] = { name: h.name, type: h.type, level: h.level }; });
                            holidaysYearCache[year] = { dates, meta };
                        })
                        .catch(() => { /* swallow; leave uncached to retry later */ })
                        .finally(() => { delete holidaysYearPending[year]; });
                    holidaysYearPending[year] = p;
                    return p;
                }
                function ensureRangeCached(startDate, endDateInclusive) {
                    const years = yearsInRangeInclusive(startDate, endDateInclusive);
                    return Promise.all(years.map(y => ensureYearCached(y)));
                }
                function buildVisibleFromCache(startDate, endDateInclusive) {
                    const resDates = new Set();
                    const resMeta = {};
                    let d = new Date(startDate);
                    while (d <= endDateInclusive) {
                        const y = d.getFullYear();
                        const yc = holidaysYearCache[y];
                        const key = ymdFromDate(d);
                        if (yc && yc.dates.has(key)) {
                            resDates.add(key);
                            if (yc.meta[key]) resMeta[key] = yc.meta[key];
                        }
                        d.setDate(d.getDate() + 1);
                    }
                    return { dates: resDates, meta: resMeta };
                }
                function updateHolidaysForCurrentView() {
                    const view = calendar.view;
                    if (!(view && view.currentStart && view.currentEnd)) return;
                    const start = new Date(view.currentStart);
                    const endInc = new Date(view.currentEnd);
                    endInc.setDate(endInc.getDate() - 1); // end is exclusive
                    return ensureRangeCached(start, endInc).then(() => {
                        const built = buildVisibleFromCache(start, endInc);
                        holidayDates = built.dates;
                        holidayMeta = built.meta;
                        syncHolidayHighlight();
                    });
                }

                const calendar = new FullCalendar.Calendar(calendarEl, {
                    themeSystem: 'bootstrap5',
                    locale: 'pt-br',
                    initialView: 'timeGridWeek',
                    // Garantir 24h em toda a UI do FullCalendar
                    eventTimeFormat: {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    },
                    slotLabelFormat: {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    },
                    // Não depender de ícones externos: sobrescrever botões com texto
                    customButtons: {
                        prev: {
                            text: '‹',
                            click: () => calendar.prev()
                        },
                        next: {
                            text: '›',
                            click: () => calendar.next()
                        },
                        prevYear: {
                            text: '≪',
                            click: () => {
                                const d = calendar.getDate();
                                calendar.gotoDate(new Date(
                                    d.getFullYear(), d.getMonth() - 1, d.getDate()
                                ));
                            }
                        },
                        nextYear: {
                            text: '≫',
                            click: () => {
                                const d = calendar.getDate();
                                calendar.gotoDate(new Date(
                                    d.getFullYear(), d.getMonth() + 1, d.getDate()
                                ));
                            }
                        },
                        settings: {
                            text: 'Configurações',
                            click: function(ev) {
                                const btn = calendarEl.querySelector('.fc-settings-button');
                                if (!btn) return;
                                toggleSettingsMenu(btn);
                            }
                        }
                    },
                    headerToolbar: {
                        left: 'prev,next today settings',
                        center: 'title',
                        right: 'prevYear,nextYear dayGridMonth,timeGridWeek,timeGridDay,listWeek,multiMonthYear'
                    },
                    buttonText: {
                        today: 'Hoje',
                        month: 'Mês',
                        week: 'Semana',
                        day: 'Dia',
                        list: 'Lista',
                        listWeek: 'Lista',
                        dayGridMonth: 'Mês',
                        timeGridWeek: 'Semana',
                        timeGridDay: 'Dia',
                        multiMonthYear: 'Ano'
                    },
                    moreLinkText: function(n) { return `+${n} mais`; },
                    views: {
                        dayGridMonth: {
                            eventDisplay: 'block'
                        },
                        multiMonthYear: {
                            type: 'multiMonth',
                            duration: {
                                years: 1
                            },
                            // boas colunas para layout 12 meses (3 col x 4 linhas)
                            multiMonthMaxColumns: 3,
                            eventDisplay: 'block',
                            buttonText: 'Ano'
                        }
                    },
                    plugins: plugins,
                    dayCellClassNames: function(arg) {
                        const iso = toLocalISO(arg.date);
                        return holidayDates.has(iso) ? ['fc-day-holiday'] : [];
                    },
                    dayCellDidMount: function(arg) {
                        const iso = toLocalISO(arg.date);
                        if (!dayCellEls[iso]) dayCellEls[iso] = [];
                        dayCellEls[iso].push(arg.el);
                        // apply immediately if data already loaded
                        if (holidayDates.has(iso)) {
                            arg.el.classList.add('fc-day-holiday');
                            const meta = holidayMeta[iso];
                            if (meta && arg.el && arg.el.setAttribute) {
                                arg.el.setAttribute('title', meta.name);
                            }
                        }
                    },
                    selectable: true,
                    editable: true,
                    nowIndicator: true,
                    navLinks: true,
                    weekends: getWeekendsSetting(),
                    eventContent: function(arg) {
                        // Semana: mostrar apenas hora inicial + título em uma linha
                        if (arg.view.type === 'timeGridWeek') {
                            const isAllDay = arg.event.allDay;
                            let timeStr = '';
                            if (!isAllDay && arg.event.start) {
                                try {
                                    timeStr = new Intl.DateTimeFormat('pt-BR', {
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        hour12: false
                                    }).format(arg.event.start);
                                } catch (e) {
                                    /* fallback */
                                    const d = arg.event.start;
                                    const hh = String(d.getHours()).padStart(2, '0');
                                    const mm = String(d.getMinutes()).padStart(2, '0');
                                    timeStr = `${hh}:${mm}`;
                                }
                            }
                            const title = arg.event.title || '';
                            // calcular duração em minutos
                            let durationMin = 0;
                            if (!isAllDay && arg.event.start && arg.event.end) {
                                durationMin = Math.max(0, Math.round((arg.event.end.getTime() - arg.event.start.getTime()) / 60000));
                            } else if (!isAllDay && arg.event.start && !arg.event.end) {
                                // sem fim explícito: assumir 60min, comum em consultas
                                durationMin = 60;
                            }
                            let html;
                            if (durationMin > 30) {
                                // duas linhas: título em cima (negrito), hora embaixo (normal)
                                const timeLine = timeStr ? `<div class=\"fc-event-time-start\">${timeStr}</div>` : '';
                                html = `<div class=\"fc-event-main-custom two-line\"><div class=\"fc-event-title\">${title}</div>${timeLine}</div>`;
                            } else {
                                // linha única: Título + hora
                                const timeInline = timeStr ? `<span class=\"fc-event-time-start\"> ${timeStr}</span>` : '';
                                html = `<div class=\"fc-event-main-custom\"><span class=\"fc-event-title\">${title}</span>${timeInline}</div>`;
                            }

                            return {
                                html
                            };
                        }
                        // Dia: Nome (negrito) - descrição do evento
                        if (arg.view.type === 'timeGridDay') {
                            const title = arg.event.title || '';
                            const notes = (arg.event.extendedProps && arg.event.extendedProps.notes) ? arg.event.extendedProps.notes : '';
                            // calcular duração em minutos (para escalar fonte)
                            let durationMin = 0;
                            if (!arg.event.allDay && arg.event.start) {
                                if (arg.event.end) {
                                    durationMin = Math.max(0, Math.round((arg.event.end.getTime() - arg.event.start.getTime()) / 60000));
                                } else {
                                    durationMin = 60; // padrão quando sem fim explícito
                                }
                            }
                            let sizeClass = '';
                            if (durationMin >= 120) sizeClass = ' size-large';
                            else if (durationMin >= 60) sizeClass = ' size-medium';
                            const sep = notes ? ' - ' : '';
                            const html = `<div class="fc-event-main-custom${sizeClass}"><span class="fc-event-title fw-bold">${title}</span>${sep}<span class="fc-event-notes">${notes}</span></div>`;
                            return {
                                html
                            };
                        }
                        // Lista: Nome (negrito) - descrição
                        if (arg.view.type && arg.view.type.startsWith('list')) {
                            const title = arg.event.title || '';
                            const notes = (arg.event.extendedProps && arg.event.extendedProps.notes) ? arg.event.extendedProps.notes : '';
                            const sep = notes ? ' - ' : '';
                            const html = `<span class="fc-event-title fw-bold">${title}</span>${sep}<span class="fc-event-notes">${notes}</span>`;
                            return {
                                html
                            };
                        }
                        // Mês: título primeiro e horário em seguida numa única linha (mantém fundo colorido padrão)
                        if (arg.view.type === 'dayGridMonth') {
                            const isAllDay = arg.event.allDay;
                            let timeStr = '';
                            if (!isAllDay && arg.event.start) {
                                try {
                                    timeStr = new Intl.DateTimeFormat('pt-BR', {
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        hour12: false
                                    }).format(arg.event.start);
                                } catch (e) {
                                    const d = arg.event.start;
                                    const hh = String(d.getHours()).padStart(2, '0');
                                    const mm = String(d.getMinutes()).padStart(2, '0');
                                    timeStr = `${hh}:${mm}`;
                                }
                            }
                            const title = arg.event.title || '';
                            const timeInline = timeStr ? `<span class=\"fc-event-time-start\"> ${timeStr}</span>` : '';
                            const html = `<div class=\"fc-event-main-custom fc-month-line\"><span class=\"fc-event-title\">${title}</span>${timeInline}</div>`;
                            return {
                                html
                            };
                        }
                        // Visualização Anual (multiMonth): mesmo layout do mês
                        if (arg.view.type && arg.view.type.startsWith('multiMonth')) {
                            const isAllDay = arg.event.allDay;
                            let timeStr = '';
                            if (!isAllDay && arg.event.start) {
                                try {
                                    timeStr = new Intl.DateTimeFormat('pt-BR', {
                                        hour: '2-digit', minute: '2-digit', hour12: false
                                    }).format(arg.event.start);
                                } catch (e) {
                                    const d = arg.event.start;
                                    const hh = String(d.getHours()).padStart(2, '0');
                                    const mm = String(d.getMinutes()).padStart(2, '0');
                                    timeStr = `${hh}:${mm}`;
                                }
                            }
                            const title = arg.event.title || '';
                            const timeInline = timeStr ? `<span class=\"fc-event-time-start\"> ${timeStr}</span>` : '';
                            const html = `<div class=\"fc-event-main-custom fc-month-line\"><span class=\"fc-event-title\">${title}</span>${timeInline}</div>`;
                            return { html };
                        }
                        // Outras visões: padrão
                        return undefined;
                    },
                    eventSources: [{
                        url: '/events',
                        method: 'GET',
                        failure: () => {
                            alert('Falha ao carregar eventos!');
                        }
                    }],
                    select: function(info) {
                        const popover = document.getElementById('eventPopover');
                        popover.style.display = 'block';
                        popover.classList.remove('visually-hidden');
                        // garantir que fica acima do popover do dia/ano
                        try { popover.style.zIndex = '4000'; } catch (e) {}
                        let x = 0,
                            y = 0;
                        if (info.jsEvent) {
                            x = info.jsEvent.clientX;
                            y = info.jsEvent.clientY;
                        } else {
                            const rect = calendarEl.getBoundingClientRect();
                            x = rect.left + rect.width / 2;
                            y = rect.top + rect.height / 2;
                        }
                        setTimeout(() => {
                            const popRect = popover.getBoundingClientRect();
                            let left = x;
                            let top = y;
                            if (left + popRect.width > window.innerWidth) left = window.innerWidth - popRect.width - 10;
                            if (left < 10) left = 10;
                            if (top + popRect.height > window.innerHeight) top = window.innerHeight - popRect.height - 10;
                            if (top < 10) top = 10;
                            popover.style.position = 'fixed';
                            popover.style.left = left + 'px';
                            popover.style.top = top + 'px';
                            popover.style.zIndex = '1060';
                        }, 10);
                        // Preencher campos do popover
                        document.getElementById('popoverEventTitle').value = '';
                        // Alterna inputs conforme allDay
                        const startInput = document.getElementById('popoverEventStart');
                        const endInput = document.getElementById('popoverEventEnd');
                        const startDateInput = document.getElementById('popoverEventStartDate');
                        const endDateInput = document.getElementById('popoverEventEndDate');
                        if (info.allDay) {
                            startInput.classList.add('visually-hidden');
                            endInput.classList.add('visually-hidden');
                            startDateInput.classList.remove('visually-hidden');
                            endDateInput.classList.remove('visually-hidden');
                            startDateInput.value = info.startStr;
                            if (info.endStr) {
                                const endDate = new Date(info.endStr);
                                endDate.setDate(endDate.getDate() - 1);
                                endDateInput.value = endDate.toISOString().slice(0, 10);
                            } else {
                                endDateInput.value = '';
                            }
                            // Se for dia inteiro, não usar datetime picker
                            try {
                                if (startInput._flatpickr) startInput._flatpickr.destroy();
                                if (endInput._flatpickr) endInput._flatpickr.destroy();
                            } catch (e) {}
                            // Aplicar flatpickr nos campos de data (dd/mm/yyyy)
                            const fpDateOpts = {
                                enableTime: false,
                                allowInput: true,
                                locale: (window.flatpickr && window.flatpickr.l10ns && window.flatpickr.l10ns.pt) ? window.flatpickr.l10ns.pt : 'pt',
                                dateFormat: 'Y-m-d', // valor real do input
                                altInput: true,
                                altFormat: 'd/m/Y' // exibição para o usuário
                            };
                            if (window.flatpickr) {
                                flatpickr(startDateInput, fpDateOpts);
                                flatpickr(endDateInput, fpDateOpts);
                            }
                        } else {
                            startInput.classList.remove('visually-hidden');
                            endInput.classList.remove('visually-hidden');
                            startDateInput.classList.add('visually-hidden');
                            endDateInput.classList.add('visually-hidden');
                            startInput.value = info.startStr.slice(0, 16);
                            // Se a seleção não tiver fim, sugerir fim = início + duração padrão
                            (function() {
                                const saved = parseInt(localStorage.getItem('defaultEventDurationMin') || '60', 10);
                                const dur = isFinite(saved) && saved > 0 ? saved : 60;
                                try {
                                    const startISO = info.startStr;
                                    const startDate = new Date(startISO);
                                    // valor sugerido pelo FullCalendar (geralmente 30min)
                                    const selectionEndISO = info.endStr || '';
                                    let useDefault = false;
                                    if (selectionEndISO) {
                                        const selEndDate = new Date(selectionEndISO);
                                        const diffMin = Math.max(0, Math.round((selEndDate.getTime() - startDate.getTime()) / 60000));
                                        // Se seleção for o slot padrão (30min) e default != 30, usar default
                                        // Se usuário arrastou mais que o default, respeitar o arrasto
                                        if (diffMin === 30 && dur !== 30) {
                                            useDefault = true;
                                        } else if (diffMin === 0) {
                                            useDefault = true;
                                        }
                                    } else {
                                        useDefault = true;
                                    }
                                    if (useDefault) {
                                        const endDate = new Date(startDate);
                                        endDate.setMinutes(endDate.getMinutes() + dur);
                                        endInput.value = formatLocalYmdHm(endDate);
                                    } else {
                                        // selectionEndISO pode conter timezone; converter para local string HH:MM
                                        const sel = new Date(selectionEndISO);
                                        endInput.value = isNaN(sel.getTime()) ? selectionEndISO.slice(0, 16) : formatLocalYmdHm(sel);
                                    }
                                } catch (e) {
                                    endInput.value = '';
                                }
                            })();
                            // Inicializar/atualizar flatpickr 24h com valores ISO (mantém value no formato ISO; mostra formato BR ao usuário)
                            try {
                                if (startInput._flatpickr) startInput._flatpickr.destroy();
                                if (endInput._flatpickr) endInput._flatpickr.destroy();
                            } catch (e) {}
                            const fpOpts = {
                                enableTime: true,
                                time_24hr: true,
                                allowInput: true,
                                minuteIncrement: 5,
                                locale: (window.flatpickr && window.flatpickr.l10ns && window.flatpickr.l10ns.pt) ? window.flatpickr.l10ns.pt : 'pt',
                                dateFormat: "Y-m-d\\TH:i", // value real enviado
                                altInput: true,
                                altFormat: "d/m/Y H:i" // o que o usuário vê
                            };
                            if (window.flatpickr) {
                                flatpickr(startInput, fpOpts);
                                flatpickr(endInput, fpOpts);
                            }
                        }
                        document.getElementById('popoverEventDesc').value = '';
                        setTimeout(() => {
                            document.getElementById('popoverEventTitle').focus();
                            // Configurar autocompletar
                            setupAutocomplete();
                        }, 50);

                        function closePopover() {
                            popover.style.display = 'none';
                            document.removeEventListener('mousedown', outsideClickListener);
                        }

                        function outsideClickListener(e) {
                            if (!popover.contains(e.target)) closePopover();
                        }
                        setTimeout(() => {
                            document.addEventListener('mousedown', outsideClickListener);
                        }, 10);
                        document.getElementById('closePopoverBtn').onclick = closePopover;
                        const form = document.getElementById('eventPopoverForm');
                        form.onsubmit = function(e) {
                            e.preventDefault();
                            const title = document.getElementById('popoverEventTitle').value;
                            let start, end;
                            if (info.allDay) {
                                start = document.getElementById('popoverEventStartDate').value;
                                end = document.getElementById('popoverEventEndDate').value;
                                if (!end) end = start;
                            } else {
                                start = document.getElementById('popoverEventStart').value;
                                end = document.getElementById('popoverEventEnd').value;
                                if (!end && start) {
                                    const dt = new Date(start);
                                    dt.setHours(dt.getHours() + 1);
                                    end = dt.toISOString().slice(0, 16);
                                }
                            }
                            if (title && start) {
                                fetch('/add_event', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            title: title,
                                            start: start,
                                            end: (function() {
                                                if (end) return end;
                                                if (info.allDay) return end; // allDay já tratado com mesma data
                                                // aplicar duração padrão ao salvar se vazio
                                                try {
                                                    const saved = parseInt(localStorage.getItem('defaultEventDurationMin') || '60', 10);
                                                    const dur = isFinite(saved) && saved > 0 ? saved : 60;
                                                    const dt = new Date(start);
                                                    dt.setMinutes(dt.getMinutes() + dur);
                                                    return formatLocalYmdHm(dt);
                                                } catch (e) {
                                                    return end;
                                                }
                                            })(),
                                            notes: document.getElementById('popoverEventDesc').value || ''
                                        })
                                    })
                                    .then(response => response.json())
                                    .then(data => {
                                        if (data.status === 'success') {
                                            calendar.refetchEvents();
                                            closePopover();
                                        } else {
                                            alert('Erro ao adicionar evento!');
                                        }
                                    });
                            }
                        };
                        calendar.unselect();
                    },
                    eventClick: function(info) {
                        document.getElementById('eventContextMenu').style.display = 'none';
                        const popover = document.getElementById('eventDetailPopover');
                        // mover para o body para evitar contextos de empilhamento e garantir topo
                        try {
                            if (popover && popover.parentElement !== document.body) {
                                document.body.appendChild(popover);
                            }
                        } catch (e) {}
                        // Formatação correta do horário (pt-BR)
                        const fmtDate = new Intl.DateTimeFormat('pt-BR', {
                            day: '2-digit',
                            month: '2-digit',
                            year: 'numeric'
                        });
                        const fmtTime = new Intl.DateTimeFormat('pt-BR', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        });

                        function buildTimeText(ev) {
                            const start = ev.start;
                            const end = ev.end;
                            if (ev.allDay) {
                                if (!end) return `${fmtDate.format(start)} (dia inteiro)`;
                                const last = new Date(end.getTime() - 24 * 60 * 60 * 1000);
                                const same = start.getFullYear() === last.getFullYear() &&
                                    start.getMonth() === last.getMonth() &&
                                    start.getDate() === last.getDate();
                                return same ?
                                    `${fmtDate.format(start)} (dia inteiro)` :
                                    `${fmtDate.format(start)} – ${fmtDate.format(last)} (dia inteiro)`;
                            } else {
                                if (end) {
                                    const sameDay = start.toDateString() === end.toDateString();
                                    return sameDay ?
                                        `${fmtDate.format(start)} ${fmtTime.format(start)} – ${fmtTime.format(end)}` :
                                        `${fmtDate.format(start)} ${fmtTime.format(start)} – ${fmtDate.format(end)} ${fmtTime.format(end)}`;
                                } else {
                                    return `${fmtDate.format(start)} ${fmtTime.format(start)}`;
                                }
                            }
                        }
                        // Preencher apenas título e horário
                        document.getElementById('detailEventTitle').textContent = info.event.title;
                        document.getElementById('detailEventTime').textContent = buildTimeText(info.event);
                        // Preencher notas (descrição)
                        const notesArea = document.getElementById('detailEventNotes');
                        const saveNotesBtn = document.getElementById('saveDetailNotesBtn');
                        if (notesArea) {
                            notesArea.value = info.event.extendedProps && info.event.extendedProps.notes ? info.event.extendedProps.notes : '';
                        }
                        if (saveNotesBtn) {
                            saveNotesBtn.onclick = function() {
                                const newNotes = notesArea ? notesArea.value : '';
                                fetch('/update_event_notes', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            id: info.event.id,
                                            notes: newNotes
                                        })
                                    })
                                    .then(r => r.json())
                                    .then(data => {
                                        if (data.status === 'success') {
                                            // Atualiza dados no cliente e refaz fetch
                                            info.event.setExtendedProp('notes', newNotes);
                                            try {
                                                calendar.refetchEvents();
                                            } catch (e) {}
                                        } else {
                                            alert('Erro ao salvar descrição.');
                                        }
                                    })
                                    .catch(() => alert('Erro ao salvar descrição.'));
                            };
                        }
                        // Buscar telefone do paciente e habilitar clique para copiar
                        const phoneSection = document.getElementById('detailEventPhoneSection');
                        const phoneDiv = document.getElementById('detailEventPhone');
                        if (phoneSection && phoneDiv) {
                            phoneSection.classList.add('hidden');
                            phoneDiv.textContent = '';
                            fetch(`/buscar_telefone?nome=${encodeURIComponent(info.event.title)}`)
                                .then(response => response.json())
                                .then(data => {
                                    const tel = (data && data.telefone) ? String(data.telefone).trim() : '';
                                    const fromNotes = (!tel && info.event.extendedProps) ?
                                        extractPhoneFromText(info.event.extendedProps.notes) :
                                        null;
                                    const finalTel = tel || (fromNotes || '');
                                    if (finalTel) {
                                        phoneDiv.textContent = finalTel;
                                        phoneDiv.classList.remove('copied');
                                        phoneSection.classList.remove('hidden');
                                        phoneDiv.onclick = async () => {
                                            try {
                                                await navigator.clipboard.writeText(finalTel);
                                                phoneDiv.classList.add('copied');
                                                setTimeout(() => phoneDiv.classList.remove('copied'), 1200);
                                            } catch (e) {
                                                const ta = document.createElement('textarea');
                                                ta.value = finalTel;
                                                document.body.appendChild(ta);
                                                ta.select();
                                                document.execCommand('copy');
                                                document.body.removeChild(ta);
                                                phoneDiv.classList.add('copied');
                                                setTimeout(() => phoneDiv.classList.remove('copied'), 1200);
                                            }
                                        };
                                    }
                                })
                                .catch(() => {
                                    // Fallback silencioso: tentar extrair do texto das notas
                                    const notes = (info.event.extendedProps && info.event.extendedProps.notes) ? String(info.event.extendedProps.notes) : '';
                                    const extracted = extractPhoneFromText(notes);
                                    if (extracted) {
                                        phoneDiv.textContent = extracted;
                                        phoneDiv.classList.remove('copied');
                                        phoneSection.classList.remove('hidden');
                                        phoneDiv.onclick = async () => {
                                            try {
                                                await navigator.clipboard.writeText(extracted);
                                                phoneDiv.classList.add('copied');
                                                setTimeout(() => phoneDiv.classList.remove('copied'), 1200);
                                            } catch (e) {
                                                const ta = document.createElement('textarea');
                                                ta.value = extracted;
                                                document.body.appendChild(ta);
                                                ta.select();
                                                document.execCommand('copy');
                                                document.body.removeChild(ta);
                                                phoneDiv.classList.add('copied');
                                                setTimeout(() => phoneDiv.classList.remove('copied'), 1200);
                                            }
                                        };
                                    }
                                });
                        }

                        // Exibir popover próximo ao clique
                        let x = 0,
                            y = 0;
                        if (info.jsEvent) {
                            x = info.jsEvent.clientX;
                            y = info.jsEvent.clientY;
                        } else {
                            const rect = calendarEl.getBoundingClientRect();
                            x = rect.left + rect.width / 2;
                            y = rect.top + rect.height / 2;
                        }
                        popover.style.display = 'block';
                        popover.classList.remove('visually-hidden');
                        try { popover.style.zIndex = '10000'; } catch (e) {}
                        setTimeout(() => {
                            const popRect = popover.getBoundingClientRect();
                            const calRect = calendarEl.getBoundingClientRect();
                            let left = x;
                            let top = y + window.scrollY;
                            if (left + popRect.width > calRect.right) left = calRect.right - popRect.width;
                            if (left < calRect.left) left = calRect.left;
                            if (top + popRect.height > calRect.bottom + window.scrollY) top = calRect.bottom + window.scrollY - popRect.height;
                            if (top < calRect.top + window.scrollY) top = calRect.top + window.scrollY;
                            popover.style.left = left + 'px';
                            popover.style.top = top + 'px';
                        }, 10);
                        // Fechar ao clicar fora ou no botão
                        function closePopover() {
                            popover.style.display = 'none';
                            popover.classList.add('visually-hidden');
                            document.removeEventListener('mousedown', outsideClickListener);
                        }

                        function outsideClickListener(e) {
                            if (!popover.contains(e.target)) closePopover();
                        }
                        setTimeout(() => {
                            document.addEventListener('mousedown', outsideClickListener);
                        }, 10);
                        document.getElementById('closeDetailPopoverBtn').onclick = closePopover;
                    },
                    eventDidMount: function(info) {
                        info.el.addEventListener('contextmenu', function(e) {
                            e.preventDefault();
                            const menu = document.getElementById('eventContextMenu');
                            let x = e.clientX,
                                y = e.clientY;
                            menu.style.display = 'block';
                            setTimeout(() => {
                                const menuRect = menu.getBoundingClientRect();
                                const calRect = calendarEl.getBoundingClientRect();
                                let left = x;
                                let top = y + window.scrollY;
                                if (left + menuRect.width > calRect.right) left = calRect.right - menuRect.width;
                                if (left < calRect.left) left = calRect.left;
                                if (top + menuRect.height > calRect.bottom + window.scrollY) top = calRect.bottom + window.scrollY - menuRect.height;
                                if (top < calRect.top + window.scrollY) top = calRect.top + window.scrollY;
                                menu.style.left = left + 'px';
                                menu.style.top = top + 'px';
                            }, 10);

                            function closeMenu() {
                                menu.style.display = 'none';
                                document.removeEventListener('mousedown', outsideClickListener);
                            }

                            function outsideClickListener(ev) {
                                if (!menu.contains(ev.target)) closeMenu();
                            }
                            setTimeout(() => {
                                document.addEventListener('mousedown', outsideClickListener);
                            }, 10);
                            document.getElementById('deleteEventBtn').onclick = function() {
                                fetch('/delete_event', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            id: info.event.id
                                        })
                                    })
                                    .then(response => response.json())
                                    .then(data => {
                                        if (data.status === 'success') {
                                            calendar.refetchEvents();
                                            closeMenu();
                                        } else {
                                            alert('Erro ao deletar evento!');
                                        }
                                    });
                            };
                            document.querySelectorAll('#colorOptions .color-circle').forEach(function(circle) {
                                circle.onclick = function() {
                                    const color = this.getAttribute('data-color');
                                    fetch('/update_event_color', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                id: info.event.id,
                                                color: color
                                            })
                                        })
                                        .then(response => response.json())
                                        .then(data => {
                                            if (data.status === 'success') {
                                                calendar.refetchEvents();
                                                closeMenu();
                                            } else {
                                                alert('Erro ao atualizar cor!');
                                            }
                                        });
                                };
                            });
                        });

                        // Enriquecer eventos no popover "+ mais" (multiMonth/dayGrid): título, horário e descrição
                        // Executa após render para garantir que o elemento esteja dentro do popover
                        setTimeout(() => {
                            const pop = info.el.closest('.fc-more-popover');
                            if (!pop) return; // apenas dentro do popover
                            try {
                                const isAllDay = info.event.allDay;
                                let timeStr = '';
                                if (!isAllDay && info.event.start) {
                                    try {
                                        timeStr = new Intl.DateTimeFormat('pt-BR', {
                                            hour: '2-digit', minute: '2-digit', hour12: false
                                        }).format(info.event.start);
                                    } catch (e) {
                                        const d = info.event.start;
                                        const hh = String(d.getHours()).padStart(2, '0');
                                        const mm = String(d.getMinutes()).padStart(2, '0');
                                        timeStr = `${hh}:${mm}`;
                                    }
                                }
                                const title = info.event.title || '';
                                const notes = (info.event.extendedProps && info.event.extendedProps.notes) ? info.event.extendedProps.notes : '';
                                const sep = timeStr ? '<span class="fc-event-time-start"> ' + timeStr + '</span>' : '';
                                const notesLine = notes ? `<div class="fc-event-notes">${notes}</div>` : '';
                                const html = `<div class="fc-event-main-custom fc-popover-rich">
                                    <div class="line1"><span class="fc-event-title">${title}</span>${sep}</div>
                                    ${notesLine}
                                </div>`;
                                const main = info.el.querySelector('.fc-event-main') || info.el.querySelector('.fc-event-main-frame') || info.el;
                                if (main) main.innerHTML = html;
                            } catch (e) { /* noop */ }
                        }, 0);
                    },
                    eventDrop: function(info) {
                        let start = info.event.startStr;
                        let end = info.event.endStr;
                        if (info.event.allDay) {
                            if (start && start.length > 10) start = start.slice(0, 10);
                            if (end && end.length > 10) end = end.slice(0, 10);
                        }
                        fetch('/update_event', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    id: info.event.id,
                                    start: start,
                                    end: end
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status !== 'success') {
                                    alert('Erro ao atualizar evento!');
                                    info.revert();
                                }
                            })
                            .catch(() => {
                                alert('Erro ao atualizar evento!');
                                info.revert();
                            });
                    },
                    eventResize: function(info) {
                        let start = info.event.startStr;
                        let end = info.event.endStr;
                        if (info.event.allDay) {
                            if (start && start.length > 10) start = start.slice(0, 10);
                            if (end && end.length > 10) end = end.slice(0, 10);
                        }
                        fetch('/update_event', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    id: info.event.id,
                                    start: start,
                                    end: end
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status !== 'success') {
                                    alert('Erro ao atualizar evento!');
                                    info.revert();
                                }
                            })
                            .catch(() => {
                                alert('Erro ao atualizar evento!');
                                info.revert();
                            });
                    }
                });
                calendar.render();

                // ===== Configurações / Temas =====
                const settingsMenu = document.getElementById('settingsMenu');

                function toggleSettingsMenu(anchorEl) {
                    if (!settingsMenu) return;
                    const isVisible = settingsMenu.style.display === 'block';
                    if (isVisible) {
                        settingsMenu.style.display = 'none';
                        settingsMenu.classList.add('visually-hidden');
                        document.removeEventListener('mousedown', outsideClickListenerSettings);
                        return;
                    }
                    // Posicionar próximo ao botão
                    const rect = anchorEl.getBoundingClientRect();
                    const top = rect.bottom + window.scrollY + 6;
                    const left = rect.left + window.scrollX;
                    settingsMenu.style.display = 'block';
                    settingsMenu.classList.remove('visually-hidden');
                    settingsMenu.style.position = 'absolute';
                    settingsMenu.style.top = top + 'px';
                    settingsMenu.style.left = left + 'px';
                    // Inicializar UI de feriados somente ao abrir o menu (lazy)
                    try { if (typeof initHolidaysUIOnce === 'function') initHolidaysUIOnce(); } catch (e) {}
                    setActiveThemeButton(localStorage.getItem('calendarTheme') || 'default');
                    (function() {
                        let saved = parseInt(localStorage.getItem('defaultEventDurationMin') || '60', 10);
                        if (!isFinite(saved) || saved <= 0 || saved === 15) {
                            saved = 60;
                            try {
                                localStorage.setItem('defaultEventDurationMin', String(saved));
                            } catch (e) {}
                        }
                        setActiveDurationButton(saved);
                    })();
                    // weekends active state
                    (function() {
                        const wk = getWeekendsSetting();
                        document.querySelectorAll('#settingsMenu [data-weekends]').forEach(btn => {
                            btn.classList.toggle('active', String(wk) === btn.getAttribute('data-weekends'));
                        });
                    })();
                    // Atualizar status do token somente agora
                    try { if (window.__fetchAndUpdateTokenBadge) window.__fetchAndUpdateTokenBadge(); } catch (e) {}
                    setTimeout(() => document.addEventListener('mousedown', outsideClickListenerSettings), 10);
                }

                function outsideClickListenerSettings(e) {
                    if (!settingsMenu.contains(e.target)) {
                        settingsMenu.style.display = 'none';
                        settingsMenu.classList.add('visually-hidden');
                        document.removeEventListener('mousedown', outsideClickListenerSettings);
                    }
                }

                function setActiveThemeButton(theme) {
                    document.querySelectorAll('#settingsMenu [data-theme]').forEach(btn => {
                        btn.classList.toggle('active', btn.getAttribute('data-theme') === theme);
                    });
                }

                function setActiveDurationButton(mins) {
                    document.querySelectorAll('#settingsMenu [data-duration]').forEach(btn => {
                        const v = parseInt(btn.getAttribute('data-duration') || '0', 10);
                        btn.classList.toggle('active', v === mins);
                    });
                }

                function applyTheme(theme, persist = true) {
                    try {
                        const link = document.getElementById('theme-override');
                        if (theme === 'default') {
                            link.removeAttribute('href');
                        } else if (theme === 'dark') {
                            link.setAttribute('href', '/static/themes/theme-dark.css');
                        } else if (theme === 'contrast') {
                            link.setAttribute('href', '/static/themes/theme-contrast.css');
                        }
                        if (persist) localStorage.setItem('calendarTheme', theme);
                    } catch (e) {
                        /* noop */ }
                }
                // Listeners dos botões do menu de configurações
                document.querySelectorAll('#settingsMenu [data-theme]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const t = btn.getAttribute('data-theme');
                        applyTheme(t);
                        setActiveThemeButton(t);
                    });
                });
                // Duração padrão do novo evento (em minutos)
                document.querySelectorAll('#settingsMenu [data-duration]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        let mins = parseInt(btn.getAttribute('data-duration') || '60', 10);
                        if (!isFinite(mins) || mins <= 0 || mins === 15) mins = 60;
                        try {
                            localStorage.setItem('defaultEventDurationMin', String(mins));
                        } catch (e) {}
                        setActiveDurationButton(mins);
                    });
                });
                // Weekends toggle (timeGridWeek)
                document.querySelectorAll('#settingsMenu [data-weekends]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const val = btn.getAttribute('data-weekends') === 'true';
                        setWeekendsSetting(val);
                        document.querySelectorAll('#settingsMenu [data-weekends]').forEach(b => {
                            b.classList.toggle('active', b === btn);
                        });
                        const viewType = calendar.view && calendar.view.type;
                        if (viewType && viewType.startsWith('timeGrid')) {
                            calendar.setOption('weekends', val);
                        }
                    });
                });

                // Re-apply weekends per view dates change
                calendar.on('datesSet', function() {
                    const val = getWeekendsSetting();
                    calendar.setOption('weekends', val);
                    updateHolidaysForCurrentView();
                });
                // prime holidays on initial render
                setTimeout(() => { updateHolidaysForCurrentView(); }, 50);
                // ==== Invertexto token and refresh (lazy init) ====
                let __holidaysUIInitialized = false;
                function initHolidaysUIOnce() {
                    if (__holidaysUIInitialized) return;
                    __holidaysUIInitialized = true;
                    const tokenInput = document.getElementById('invertextoToken');
                    const yearInput = document.getElementById('holidaysYear');
                    const ufInput = document.getElementById('holidaysState');
                    const btn = document.getElementById('btnRefreshHolidays');
                    const statusEl = document.getElementById('holidaysStatus');
                    const clearBtn = document.getElementById('btnClearToken');
                    const tokenBadge = document.getElementById('tokenStatusBadge');
                    if (!tokenInput || !yearInput || !btn) return;
                    // Prefill year
                    try {
                        yearInput.value = String(new Date().getFullYear());
                    } catch (e) {}
                    // Check if token configured
                    function updateTokenBadge(has) {
                        if (!tokenBadge) return;
                        tokenBadge.textContent = has ? 'Token configurado' : 'Token não configurado';
                        tokenBadge.className = has ? 'badge bg-success' : 'badge bg-secondary';
                    }
                    function fetchAndUpdateTokenBadge() {
                        return fetch('/settings/invertexto_token')
                            .then(r => r.json())
                            .then(j => {
                                const has = !!(j && j.hasToken);
                                if (!has) statusEl.textContent = 'Token não configurado.';
                                updateTokenBadge(has);
                            })
                            .catch(() => {});
                    }
                    // Expor para chamada quando abrir o menu
                    window.__fetchAndUpdateTokenBadge = fetchAndUpdateTokenBadge;
                    // Save token on blur
                    function saveToken(value) {
                        const v = (value || '').trim();
                        if (!v) return Promise.resolve();
                        statusEl.textContent = 'Salvando token...';
                        return fetch('/settings/invertexto_token', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                token: v
                            })
                        }).then(r => r.json()).then(j => {
                            if (j && j.status === 'success') {
                                statusEl.textContent = 'Token salvo.';
                                tokenInput.value = '';
                                updateTokenBadge(true);
                            } else {
                                statusEl.textContent = 'Falha ao salvar token.';
                            }
                        }).catch(() => {
                            statusEl.textContent = 'Erro ao salvar token.';
                        });
                    }
                    if (clearBtn) {
                        clearBtn.addEventListener('click', () => {
                            fetch('/settings/invertexto_token', {
                                    method: 'DELETE'
                                })
                                .then(r => r.json())
                                .then(j => {
                                    if (j && j.status === 'success') {
                                        statusEl.textContent = 'Token removido.';
                                        updateTokenBadge(false);
                                    } else {
                                        statusEl.textContent = 'Falha ao remover token.';
                                    }
                                })
                                .catch(() => {
                                    statusEl.textContent = 'Erro ao remover token.';
                                });
                        });
                    }
                    tokenInput.addEventListener('change', () => {
                        saveToken(tokenInput.value);
                    });
                    // Refresh action
                    btn.addEventListener('click', () => {
                        const year = parseInt(yearInput.value || '0', 10);
                        const uf = (ufInput && ufInput.value || '').toUpperCase().trim();
                        if (!year || year < 1900) {
                            statusEl.textContent = 'Ano inválido.';
                            return;
                        }
                        statusEl.textContent = 'Atualizando feriados...';
                        const maybeToken = (tokenInput.value || '').trim();
                        const doRefresh = () => fetch('/holidays/refresh', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                year: year,
                                state: uf || undefined
                            })
                        }).then(r => r.json()).then(j => {
                            if (j && j.status === 'success') {
                                statusEl.textContent = `Atualizado. ${j.count||0} registros.`;
                                // Invalidate year cache and rebuild for current view
                                for (const y in holidaysYearCache) delete holidaysYearCache[y];
                                for (const y in holidaysYearPending) delete holidaysYearPending[y];
                                try { updateHolidaysForCurrentView(); } catch (e) {}
                            } else {
                                const msg = (j && j.message) ? j.message : 'Falha ao atualizar.';
                                statusEl.textContent = msg + (msg.includes('Não autorizado') ? ' Verifique o token e tente novamente.' : '');
                            }
                        }).catch(() => {
                            statusEl.textContent = 'Erro ao atualizar.';
                        });
                        if (maybeToken) {
                            saveToken(maybeToken).then(doRefresh);
                        } else {
                            doRefresh();
                        }
                    });
                }

                // Função para configurar autocompletar nativo
                function setupAutocomplete() {
                    const titleInput = document.getElementById('popoverEventTitle');
                    const datalist = document.getElementById('namesList');
                    let currentTimeout = null;
                    let suggestions = [];
                    let currentIndex = -1;

                    titleInput.addEventListener('input', function() {
                        const query = this.value.trim();
                        // Limpar timeout anterior
                        if (currentTimeout) {
                            clearTimeout(currentTimeout);
                        }
                        if (query.length >= 1) {
                            // Aguardar 300ms antes de fazer a busca
                            currentTimeout = setTimeout(() => {
                                fetch(`/buscar_nomes?q=${encodeURIComponent(query)}`)
                                    .then(response => response.json())
                                    .then(nomes => {
                                        suggestions = nomes;
                                        currentIndex = -1;
                                        updateDatalist(nomes);
                                    })
                                    .catch(error => {
                                        console.error('Erro ao buscar nomes:', error);
                                        datalist.innerHTML = '';
                                        suggestions = [];
                                    });
                            }, 300);
                        } else {
                            datalist.innerHTML = '';
                            suggestions = [];
                            currentIndex = -1;
                        }
                    });

                    titleInput.addEventListener('keydown', function(e) {
                        if (e.key === 'Tab' && suggestions.length > 0) {
                            e.preventDefault();
                            currentIndex = (currentIndex + 1) % suggestions.length;
                            this.value = suggestions[currentIndex];
                        }
                    });

                    function updateDatalist(nomes) {
                        datalist.innerHTML = '';
                        nomes.forEach(nome => {
                            const option = document.createElement('option');
                            option.value = nome;
                            datalist.appendChild(option);
                        });
                    }
                }
            });
        });
    </script>

</body>

</html>